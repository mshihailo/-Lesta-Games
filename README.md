# -Lesta-Games
Выполненное тестовое задание для Lesta Games
Вопрос №1

На языке Python или C++ написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 

Пример: 

def isEven(value):

      return value % 2 == 0

Ответ №1

Реализация, представленная в задании:

Плюсы:

1. Более интуитивно понятна и легче воспринимается(теми, кто не знакомым с побитовыми операциями).
2. Универсальность, то бишь(работает с любыми числовыми типами).

Минусы:

1. Операция %  может быть менее производительной, чем побитовые операции на некоторых процессорах.
2. При работе с отрицательными числами могут возникнуть сложности, так как поведение % с отрицательными числами зависит от компилятора.

Реализация, написанная мной:

Плюсы:

1. Побитовая операция & работает быстрее, чем операция %, поскольку выполняется на уровне битов и обычно занимает меньше процессорного времени.
2. Простая и весьма эффективная проверка для целых чисел, особенно полезная в системах, где производительность критична.

Минусы:

1. Менее очевидная логика для начинающих прогеров.
2. Подходит только для целых чисел, не работает с числами с плавающей точкой.

Вопрос №2

На языке Python или С++ написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Оценивается:

Полнота и качество реализации
Оформление кода
Наличие сравнения и пояснения по быстродействию

Ответ №2

Реализация 1 на основе массива с использованием указателей.

Плюсы:

1. Простая реализация на основе массива, что позволяет использовать статическую память.
2. Быстрое добавление и удаление элементов, так как все операции выполняются за О(1).
3. Малое потребление памяти, так как не требуется дополнительных структур.

Минусы:

1. Размер буфера должен быть известен заранее и не может быть изменён во время работы.
2. При заполнении буфера потребуется дополнительная логика для перезаписи старых данных или их удаления, если это необходимо.

Реализация 2 на основе динамического массива с автоматическим изменением размера

Плюсы: 

1. Динамическое изменение размера позволяет буферизировать данные по мере необходимости, избегая переполнения и обеспечивая гибкость.
2. Стандартный контейнер vector автоматически управляет памятью, что снижает риск ошибок, связанных с управлением ресурсами.

Минусы:

1. Меньшая производительность при переполнении буфера, так как для увеличения размера требуется копирование данных, что увеличивает временную сложность.
2. Большое потребление памяти при значительном росте данных, так как каждый раз буфер удваивает свою емкость.

Вопрос №3

На языке Python или С++ предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.

Ответ №3

Introsort использует быструю сортировку для максимальной эффективности в среднем случае и пирамидальную сортировку для устранения худшего случая, обеспечивая таким образом гарантированную производительность O(nlogn) для массивов любого размера. Также сочетание нескольких алгоритмов делает Introsort универсальным для любых входных данных, будь то случайный порядок, частично отсортированные массивы или массивы с большим количеством повторений. Помимо этого переключение между сортировками выполняется по мере необходимости, что позволяет эффективно использовать разные подходы в зависимости от текущего состояния массива и достигнутой глубины рекурсии.
